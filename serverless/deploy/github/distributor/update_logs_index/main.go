// Copyright 2021 Google LLC. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// update_logs_index is a tool to manage a markdown file containing a list of
// human-readable links to the log directories maintained by the distributor.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/golang/glog"
	"github.com/google/trillian-examples/serverless/config"
	"golang.org/x/mod/sumdb/note"
	"gopkg.in/yaml.v2"

	i_note "github.com/google/trillian-examples/internal/note"
)

var (
	storageDir = flag.String("distributor_dir", "", "Root directory of the distributor.")
	configFile = flag.String("config", "", "Distributor config file.")
	outputFile = flag.String("output", "log_index.md", "Markdown file to write.")
)

const tmpl = `# {{.Title}}

## Known Logs
| Origin | SignedBy |
|--------|----------|
{{range .Logs}}| [{{.Origin}}](./{{.ID}}) | {{.SignedBy}} | {{"\n"}}{{end}} 

## Known Witnesses

| SignedBy |
|----------|
{{range .Witnesses}}| {{.}} | {{"\n"}}{{end}}


This file was autogenerated from the [distributor config]({{.Config}}).
`

type logInfo struct {
	ID       string
	Origin   string
	SignedBy string
	URL      string
}

type distConfig struct {
	Logs      []logInfo
	Witnesses []string
}

func main() {
	flag.Parse()
	cfgPath := filepath.Join(*storageDir, *configFile)
	cfg, err := loadConfig(cfgPath)
	if err != nil {
		glog.Exitf("Failed to read config: %v", err)
	}

	tArgs := struct {
		distConfig
		Title  string
		Config string
	}{
		distConfig: *cfg,
		Title:      "Log index",
		Config:     fmt.Sprintf("/%s", *configFile),
	}

	md := bytes.Buffer{}
	t := template.Must(template.New("Index").Parse(tmpl))
	if err := t.Execute(&md, tArgs); err != nil {
		glog.Exitf("Failed to execute template: %v", err)
	}

	outPath := filepath.Join(*storageDir, *outputFile)
	if err := os.WriteFile(outPath, md.Bytes(), 0644); err != nil {
		glog.Exitf("Failed to write to %q: %v", outPath, err)
	}
}

func loadConfig(f string) (*distConfig, error) {
	cfg := &struct {
		Logs      []config.Log `yaml:"Logs"`
		Witnesses []string     `yaml:"Witnesses"`
	}{}
	raw, err := os.ReadFile(f)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file %q: %v", f, err)
	}
	if err := yaml.Unmarshal(raw, cfg); err != nil {
		return nil, fmt.Errorf("failed to parse config: %v", err)
	}

	ret := &distConfig{}

	for wi, w := range cfg.Witnesses {
		sv, err := note.NewVerifier(w)
		if err != nil {
			return nil, fmt.Errorf("failed to instantiate public key for witness at index %d: %v", wi, err)
		}
		ret.Witnesses = append(ret.Witnesses, sv.Name())
	}

	for li, l := range cfg.Logs {
		sv, err := i_note.NewVerifier(l.PublicKeyType, l.PublicKey)
		if err != nil {
			return nil, fmt.Errorf("failed to instantiate public key for log at index %d: %v", li, err)
		}
		ret.Logs = append(ret.Logs, logInfo{
			ID:       l.ID,
			Origin:   l.Origin,
			SignedBy: sv.Name(),
			URL:      l.URL,
		})
	}
	return ret, nil
}
